Architektury Výpočetních Systémů (AVS 2023)
Projekt č. 2 (PMC)
Login: xchoch09

Úloha 1: Paralelizace původního řešení
===============================================================================

1) Kterou ze smyček (viz zadání) je vhodnější paralelizovat a co způsobuje 
   neefektivitu paralelizaci té druhé?

   Vhodnější je paralelizovat vnější smyčku, tedy smyčku v metodě marchCubes().
   Neefektivita paralelizace vnitřní smyčky (v metodě evaluateFieldAt()) je
   způsobena tím, že je paralelizována pouze malá část kódu. Zároveň je
   vyžadována velká režie paralelizace a stále významná část kódu je
   zpracovávána sekvenčně.

2) Jaké plánování (rozdělení práce mezi vlákna) jste zvolili a proč? 
   Jaký vliv má velikost "chunk" při dynamickém plánování (8, 16, 32, 64)?

   Z výsledků testování jednotlivých variant plánování bylo zvoleno plánování
   "guided", které se v průměru ukázalo jako nejrychlejší s nejlepší
   efektivitou využití CPU.

   Velikost "chunk" má při dynamickém plánování vliv takový, že čím větší je
   tato hodnota, tím hůře se vyvažuje práce mezi všechna vlákna. Naopak čím
   menší je daná hodnota, tím více je vybalancovaný systém, ale naopak je
   vyšší režie při rozdělování iterací. Na základě měření nebyl pozorován
   významný rozdíl, mezi jednotlivými nastaveními velikosti "chunk". Ovšem lze
   prohlásit, že pro menší hodnoty s větší četností docházelo k pomalejším
   běhům a horší efektivitě využití CPU. Dané změny chování pro totožnou
   velikost "chunk" jsou především způsobeny tím, jak moc je běh programu
   bržděn režií při rozdělování iterací.

3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

   Jako datová struktura pro ukládání trojúhelníků byl zvolen vektor ze
   standardní knihovny jazyka C++ (std::vector) stejně jako je tomu v
   referenční implementaci. Nyní ovšem je nutné použít pragmu z knihovny
   OpenMP, a to pragmu "critical", tudíž ukládání trojúhelníků je prováděno v
   rámci tzv. kritické sekce. Tato pragma je důležitá z toho důvodu, že
   jednotlivá vlákna přidávají trojúhelníky na konec vektoru, přičemž díky
   jejímu použití je zařízeno, že trojúhelník může ukládat pouze jedno vlákno
   (ostatní čekají, pokud se nacházejí přímo před kritickou sekcí), přičemž
   nezáleží na pořadí vkládání jednotlivých trojúhelníků.


Úloha 2: Paralelní průchod stromem
===============================================================================

1) Stručně popište použití OpenMP tasků ve vašem řešení.

   Nejprve je ve funkci marchCubes() vytvořena paralelní sekce, ve které
   hlavní vlákno provede volání rekurzivní funkce treeTraversal(). V této
   funkci jsou vytvářeny tasky pro rekurzivní volání téže funkce pro 8
   podstromů.

2) Jaký vliv má na vaše řešení tzv. "cut-off"? Je vhodné vytvářet nový 
   task pro každou krychli na nejnižší úrovni?

   Tzv. "cut-off" určuje maximální délku hrany (počet krychlí jedné hrany
   mřížky), od které nejsou dále vytvářeny tasky pro další větvení stromu, ale
   namísto toho je již volána metoda buildCube() pro generování polygonů.
   V rámci implementace byla zvolena délka hrany 4. Pokud je délka hrany menší
   nebo rovna 4, dochází následně k sekvenčnímu zpracování a ke generování
   polygonů pro všechny krychle daného podprostoru.

   Na základě měření není vhodné vytvářet task pro každou krychli na nejnižší
   úrovni.

3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

   Ukládání trojuhelníků je implementováno totožně jako pro paralerní verzi
   původního řešení (std::vector a #pragma omp critical).

Úloha 3: Grafy škálování všech řešení
===============================================================================

1) Stručně zhodnoťte efektivitu vytvořených řešení (na základě grafů ŠKÁLOVÁNÍ).

   Obě varianty implementace disponují vhodným silným škálováním do počtu 16
   vláken. Od více jak 32 vláken včetně efektivita obou implementačních variant
   značně klesá. Tudíž pro obě varianty implementace platí, že při zvýšení
   počtu vláken dochází ke zkrácení času výpočtu až do počtu 16 vláken.

   Varianta implementace "loop" je s rostoucím počtem vláken efektivnější než
   varianta "tree", ovšem čas běhu je delší. Pro variantu "tree" zároveň platí,
   že při velmi malých vstupech (10) nedochází ke snížení času výpočtu při
   vyšším počtu vláken, tudíž je při takových vstupech málo efektivní.

2) V jakém případě (v závislosti na počtu bodů ve vstupním souboru a velikosti 
   mřížky) bude vaše řešení 1. úlohy neefektivní? (pokud takový případ existuje)

   Vlastní řešení 1. úlohy bude neefektivní při velmi malém vstupu a velkém
   počtu výpočetních vláken.

3) Je (nebo není) stromový algoritmus efektivnější z pohledu slabého škálování 
   vzhledem ke vstupu?

   Z pohledu slabého škálování pro stromový algoritmus platí, že pro menší
   vstupy se zvyšováním počtu vláken narůstá i čas výpočtu, a tudíž pro takové
   vstupy není daný algoritmus efektivní. Pro větší vstupy se postupně
   efektivita stromového algoritmu zlepšuje (křivka pro danou velikost vstupu
   se přibližuje k ideálnímu tvaru dle teorie, viz další otázka).

4) Jaký je rozdíl mezi silným a slabým škálováním?

   Silné škálování ponechává konstantní celkovou práci a je měněna míra
   paralelizace (počet vláken). Vychází z Amdahlova zákona. Dané škálování tedy
   zobrazuje změny doby výpočtu v závislosti na počtu vláken při totožné
   velikosti vstupu. Ideální křivka je taková křivka, která postupně klesá (s
   vyšším počtem vláken je doba potřebná pro provedení výpočtu kratší).

   Naopak při slabém škálování je uvažován konstantní čas výpočtu na vlákno,
   přičemž je zobrazována doba výpočtu v závislosti na velikosti vstupu pro
   každé vlákno. Vychází z Gustafsonova zákona. Ideální křivka je taková
   křivka, která je konstantní (rovnoběžná s osou označující počet vláken),
   tudíž při vyšším počtu vláken a při současně větší velikosti vstupu, přičemž
   obojí se mění lineárně, je doba výpočtu stejná.

Úloha 4: Analýza využití jader pomocí VTune
================================================================================

1) Jaké bylo průměrné využití jader pro všechny tři implementace s omezením na 
   18 vláken? Na kolik procent byly využity?

   ref: 2.8% (0.998 out of 36 logical CPUs)
   loop: 48.6% (17.507 out of 36 logical CPUs)
   tree: 45.5% (16.373 out of 36 logical CPUs)

2) Jaké bylo průměrné využití jader pro všechny tři implementace s využitím 
   všech jader? Na kolik procent se podařilo využít obě CPU?
   
   ref: 2.8% (0.998 out of 36 logical CPUs)
   loop: 91.8% (33.031 out of 36 logical CPUs)
   tree: 78.3% (28.197 out of 36 logical CPUs)

3) Jaké jsou závěry z těchto měření?

   Obě implementační varianty, jak "loop", tak i "tree", jsou efektivnější než
   referenční řešení. Dále varianta "loop" dokáže vytížit více vláken oproti
   variantě "tree", tudíž bude efektivnější při vysokém počtu vláken.
