Architektury Výpočetních Systémů (AVS 2023)
Projekt č. 2 (PMC)
Login: xchoch09

Úloha 1: Paralelizace původního řešení
===============================================================================

1) Kterou ze smyček (viz zadání) je vhodnější paralelizovat a co způsobuje 
   neefektivitu paralelizaci té druhé?

   Vhodnější je paralelizovat vnější smyčku, tedy smyčku v metodě marchCubes().
   Neefektivita paralelizace vnitřní smyčky (v metodě evaluateFieldAt()) je
   způsobena tím, že je paralelizována pouze malá část kódu. Zároveň je
   vyžadována velká režie paralelizace a stále významná část kódu je
   zpracovávána sekvenčně.

2) Jaké plánování (rozdělení práce mezi vlákna) jste zvolili a proč? 
   Jaký vliv má velikost "chunk" při dynamickém plánování (8, 16, 32, 64)?

   Z výsledků testování jednotlivých variant plánování bylo zvoleno plánování
   "guided", které se v průměru ukázalo jako nejrychlejší s nejlepší
   efektivitou využití CPU.

   Velikost "chunk" má při dynamickém plánování vliv takový, že čím větší je
   tato hodnota, tím hůře se vyvažuje práce mezi všechna vlákna. Naopak čím
   menší je daná hodnota, tím více je vybalancovaný systém, ale naopak je
   vyšší režie při rozdělování iterací. Na základě měření nebyl pozorován
   významný rozdíl, mezi jednotlivými nastaveními velikosti "chunk". Ovšem lze
   prohlásit, že pro menší hodnoty s větší četností docházelo k pomalejším
   běhům a horší efektivitě využití CPU. Dané změny chování pro totožnou
   velikost "chunk" jsou především způsobeny tím, jak moc je běh programu
   bržděn režií při rozdělování iterací.

3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

   Jako datová struktura pro ukládání trojúhelníků byl zvolen vektor ze
   standardní knihovny jazyka C++ (std::vector) stejně jako je tomu v
   referenční implementaci. Nyní ovšem je nutné použít pragmu z knihovny
   OpenMP, a to pragmu "critical", tudíž ukládání trojúhelníků je prováděno v
   rámci tzv. kritické sekce. Tato pragma je důležitá z toho důvodu, že
   jednotlivá vlákna přidávají trojúhelníky na konec vektoru, přičemž díky
   jejímu použití je zařízeno, že trojúhelník může ukládat pouze jedno vlákno
   (ostatní čekají, pokud se nacházejí přímo před kritickou sekcí), přičemž
   nezáleží na pořadí vkládání jednotlivých trojúhelníků.


Úloha 2: Paralelní průchod stromem
===============================================================================

1) Stručně popište použití OpenMP tasků ve vašem řešení.

   Nejprve je ve funkci marchCubes() vytvořena paralelní sekce, ve které
   hlavní vlákno provede volání rekurzivní funkce treeTraversal(). V této
   funkci jsou vytvářeny tasky pro rekurzivní volání téže funkce pro 8
   podstromů.

2) Jaký vliv má na vaše řešení tzv. "cut-off"? Je vhodné vytvářet nový 
   task pro každou krychli na nejnižší úrovni?

   Tzv. "cut-off" určuje minimální délku hrany, od které již nejsou vytvářeny
   tasky pro další větvení stromu, ale namísto toho je již zavolána metoda
   buildCube() pro generování polygonů. Tím tato hodnota zároveň určuje úroveň
   listů stromu. V rámci implementace byla zvolena délka hrany 1. Pokud je
   délka hrany menší nebo rovna 1, dochází ke generování polygonů. Jelikož dle
   zadání je předpokládáno, že velikost mřížky je v mocninách 2, při dělení
   dané hodnoty hodnotou 2 (na poloviny) postupně musí délka hrany být přesně
   1, a tudíž lze porovnávat délku hrany pouze pomocí rovnosti.

   Na základě měření není vhodné vytvářet task pro každou krychli na nejnižší
   úrovni.

3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

   Ukládání trojuhelníků je implementováno totožně jako pro paralerní verzi
   původního řešení (std::vector a #pragma omp critical).

Úloha 3: Grafy škálování všech řešení
===============================================================================

1) Stručně zhodnoťte efektivitu vytvořených řešení (na základě grafů ŠKÁLOVÁNÍ).

   Obě varianty implementace disponují vhodným silným škálováním do počtu 16
   vláken. Od více jak 32 vláken včetně efektivita obou implementačních variant
   značně klesá. Tudíž pro obě varianty implementace platí, že při zvýšení
   počtu vláken dochází ke zkrácení času výpočtu až do počtu 16 vláken.

   Varianta implementace "loop" je s rostoucím počtem vláken efektivnější než
   varianta "tree", ovšem čas běhu je delší. Pro variantu "tree" zároveň platí,
   že při velmi malých vstupech (10) nedochází ke snížení času výpočtu při
   vyšším počtu vláken, tudíž je při takových vstupech málo efektivní.

2) V jakém případě (v závislosti na počtu bodů ve vstupním souboru a velikosti 
   mřížky) bude vaše řešení 1. úlohy neefektivní? (pokud takový případ existuje)

   Vlastní řešení 1. úlohy bude neefektivní při velmi malém vstupu a velkém
   počtu výpočetních vláken.

3) Je (nebo není) stromový algoritmus efektivnější z pohledu slabého škálování 
   vzhledem ke vstupu?

   Ano je efektivnější oproti variantě "loop", ovšem pouze do určitého počtu
   vláken (cca 16 včetně - 2^4). Na základě grafů lze předpokládat, že při
   větším počtu jader, než bylo testováno, bude mít implementace "loop" lepší
   škálování.

4) Jaký je rozdíl mezi silným a slabým škálováním?
   Silné škálování ponechává konstantní celkovou práci a je měněna míra
   paralelizace (počet vláken). Vychází z Amdahlova zákona. Dané škálování tedy
   zobrazuje změny doby výpočtu v závislosti na počtu vláken při totožné
   velikosti vstupu. Ideální křivka je taková křivka, která postupně klesá (s
   větším počtem vláken je doba potřebná pro provedení výpočtu kratší).

   Naopak při slabém škálování je ideálně uvažován konstantní čas výpočtu na
   vlákno, přičemž je zobrazována doba výpočtu v závislosti na velikosti vstupu
   pro každé vlákno. Vychází z Gustafsonova zákona. Ideální křivka je taková
   křivka, která je konstantní (rovnoběžná s osou označující počet vláken),
   tudíž při vyšším počtu vláken a při současně větší velikosti vstupu, přičemž
   obě se mění lineárně, je doba výpočtu stejná.

Úloha 4: Analýza využití jader pomocí VTune
================================================================================

1) Jaké bylo průměrné využití jader pro všechny tři implementace s omezením na 
   18 vláken? Na kolik procent byly využity?
   
   ref: 2.8% (0.998 out of 36 logical CPUs)
   loop:
   tree:

2) Jaké bylo průměrné využití jader pro všechny tři implementace s využitím 
   všech jader? Na kolik procent se podařilo využít obě CPU?
   
   ref: 2.8% (0.998 out of 36 logical CPUs)
   loop:
   tree:

3) Jaké jsou závěry z těchto měření?
   Obě implementační varianty, jak "loop", tak i "tree", jsou efektivnější než
   referenční řešení. Dále varianta "loop" dokáže vytížit více vláken oproti
   variantě "tree", tudíž bude efektivnější při velkém počtu vláken.
